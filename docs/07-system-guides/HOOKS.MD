# BUMBA Universal Hook System Documentation

## Table of Contents

1. [Overview](#overview)
2. [Architecture](#architecture)
3. [Hook Categories](#hook-categories)
4. [Complete Hook Reference](#complete-hook-reference)
5. [Usage Guide](#usage-guide)
6. [Examples](#examples)
7. [Best Practices](#best-practices)
8. [Performance Considerations](#performance-considerations)
9. [Troubleshooting](#troubleshooting)

## Overview

The BUMBA Universal Hook System is a comprehensive event-driven architecture that provides extensibility across all major framework components. With 45+ hook points, it enables custom behaviors, cost optimization, and system monitoring without modifying core code.

### Key Benefits

- **ðŸª Extensibility**: Add custom logic at any point in the system lifecycle
- **ðŸŸ¢ Cost Optimization**: 30-40% cost savings through intelligent model selection
- **ðŸŸ¢ Non-invasive**: Extend functionality without modifying core code
- **ðŸŸ¢ Observability**: Monitor and track all system operations
- **ðŸŸ¢ Fine-grained Control**: Precise control over system behavior

## Architecture

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚       BumbaUniversalHookSystem             â”‚
â”‚                                            â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚         Hook Registry                 â”‚ â”‚
â”‚  â”‚  â€¢ 45+ registered hooks              â”‚ â”‚
â”‚  â”‚  â€¢ Priority-based execution          â”‚ â”‚
â”‚  â”‚  â€¢ Category organization             â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”‚                                            â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚       Handler Registry                â”‚ â”‚
â”‚  â”‚  â€¢ Multiple handlers per hook        â”‚ â”‚
â”‚  â”‚  â€¢ Async execution support           â”‚ â”‚
â”‚  â”‚  â€¢ Error isolation                   â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”‚                                            â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚      Execution Engine                 â”‚ â”‚
â”‚  â”‚  â€¢ Sequential processing              â”‚ â”‚
â”‚  â”‚  â€¢ Context passing                    â”‚ â”‚
â”‚  â”‚  â€¢ Result aggregation                 â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

## Hook Categories

### 1. **Team Hooks** (`team:*`)
Control team composition and validation

### 2. **Model Hooks** (`model:*`)
Manage model selection and cost optimization

### 3. **Lifecycle Hooks** (`lifecycle:*`)
Agent state transitions and lifecycle events

### 4. **Deprecation Hooks** (`deprecation:*`)
Agent retirement and cleanup strategies

### 5. **Knowledge Hooks** (`knowledge:*`)
Knowledge transfer and preservation

### 6. **API Hooks** (`api:*`)
API request/response handling

### 7. **Department Hooks** (`department:*`)
Cross-department coordination

### 8. **Manager Hooks** (`manager:*`)
Manager decision validation

### 9. **Orchestrator Hooks** (`orchestrator:*`)
System-wide orchestration events

### 10. **Claude Max Hooks** (`claudemax:*`)
Claude Max lock management

## Complete Hook Reference

### Team Composition Hooks

#### `team:beforeComposition`
**Trigger**: Before team composition begins  
**Context**:
```javascript
{
  teamId: string,
  task: object,
  availableAgents: array,
  config: object
}
```
**Use Cases**: Filter available agents, modify task requirements

#### `team:validateComposition`
**Trigger**: After initial team composition  
**Context**:
```javascript
{
  composition: object,
  valid: boolean,
  errors: array
}
```
**Use Cases**: Enforce team size limits, validate skill coverage

#### `team:modifyComposition`
**Trigger**: Before finalizing team  
**Context**:
```javascript
{
  composition: object,
  modifications: object
}
```
**Use Cases**: Add/remove members, change team structure

#### `team:afterComposition`
**Trigger**: After team is finalized  
**Context**:
```javascript
{
  team: object,
  duration: number,
  strategy: string
}
```
**Use Cases**: Track metrics, log team formation

### Model Selection Hooks

#### `model:beforeSelection`
**Trigger**: Before model selection  
**Context**:
```javascript
{
  requirements: object,
  availableModels: array,
  config: object
}
```
**Use Cases**: Filter model choices, set preferences

#### `model:evaluateCost`
**Trigger**: During cost evaluation  
**Context**:
```javascript
{
  model: string,
  cost: number,
  requirements: object,
  suggestAlternative: boolean
}
```
**Use Cases**: Cost optimization, budget enforcement

#### `model:suggestAlternative`
**Trigger**: When alternative needed  
**Context**:
```javascript
{
  originalModel: string,
  reason: string,
  alternativeModel: string,
  costSavings: number
}
```
**Use Cases**: Fallback strategies, cost reduction

#### `model:afterSelection`
**Trigger**: After model selected  
**Context**:
```javascript
{
  selectedModel: string,
  estimatedCost: number,
  agentId: string
}
```
**Use Cases**: Track model usage, calculate savings

### Lifecycle State Hooks

#### `lifecycle:beforeTransition`
**Trigger**: Before state transition  
**Context**:
```javascript
{
  agentId: string,
  currentState: string,
  event: string,
  targetState: string,
  context: object
}
```
**Use Cases**: Prevent transitions, validate conditions

#### `lifecycle:validateTransition`
**Trigger**: During transition validation  
**Context**:
```javascript
{
  agentId: string,
  transition: object,
  valid: boolean,
  errors: array
}
```
**Use Cases**: Enforce state rules, check prerequisites

#### `lifecycle:modifyTransition`
**Trigger**: Before executing transition  
**Context**:
```javascript
{
  agentId: string,
  transition: object,
  modifications: object
}
```
**Use Cases**: Add metadata, modify transition data

#### `lifecycle:afterTransition`
**Trigger**: After state transition  
**Context**:
```javascript
{
  agentId: string,
  previousState: string,
  currentState: string,
  duration: number
}
```
**Use Cases**: Log transitions, update metrics

#### `lifecycle:onError`
**Trigger**: On transition error  
**Context**:
```javascript
{
  agentId: string,
  error: object,
  state: string,
  recovery: object
}
```
**Use Cases**: Error recovery, fallback handling

### Deprecation Hooks

#### `deprecation:before`
**Trigger**: Before deprecation starts  
**Context**:
```javascript
{
  agentId: string,
  reason: string,
  strategy: string,
  metadata: object
}
```
**Use Cases**: Capture final state, prepare cleanup

#### `deprecation:overrideStrategy`
**Trigger**: During strategy selection  
**Context**:
```javascript
{
  agentId: string,
  originalStrategy: string,
  suggestedStrategy: string,
  reason: string
}
```
**Use Cases**: Change deprecation approach

#### `deprecation:prevent`
**Trigger**: Before deprecation execution  
**Context**:
```javascript
{
  agentId: string,
  reason: string,
  conditions: array,
  prevent: boolean
}
```
**Use Cases**: Prevent premature deprecation

#### `deprecation:customCleanup`
**Trigger**: During cleanup phase  
**Context**:
```javascript
{
  agentId: string,
  resources: object,
  cleanupActions: array
}
```
**Use Cases**: Custom resource cleanup

#### `deprecation:after`
**Trigger**: After deprecation complete  
**Context**:
```javascript
{
  agentId: string,
  success: boolean,
  duration: number,
  knowledgeTransferred: boolean
}
```
**Use Cases**: Log deprecation, update statistics

### Knowledge Transfer Hooks

#### `knowledge:beforeTransfer`
**Trigger**: Before knowledge transfer  
**Context**:
```javascript
{
  fromAgent: string,
  toAgent: string,
  knowledge: object,
  method: string
}
```
**Use Cases**: Validate transfer, prepare data

#### `knowledge:filter`
**Trigger**: During knowledge filtering  
**Context**:
```javascript
{
  knowledge: object,
  filters: array,
  agent: string
}
```
**Use Cases**: Remove sensitive data, filter by relevance

#### `knowledge:transform`
**Trigger**: During knowledge transformation  
**Context**:
```javascript
{
  knowledge: object,
  transformations: array,
  targetAgent: string
}
```
**Use Cases**: Format conversion, data enrichment

#### `knowledge:validateTransfer`
**Trigger**: Before finalizing transfer  
**Context**:
```javascript
{
  fromAgent: string,
  toAgent: string,
  knowledge: object,
  valid: boolean,
  errors: array
}
```
**Use Cases**: Ensure data integrity, validate compatibility

#### `knowledge:afterTransfer`
**Trigger**: After transfer complete  
**Context**:
```javascript
{
  fromAgent: string,
  toAgent: string,
  transferredItems: number,
  success: boolean
}
```
**Use Cases**: Log transfers, update metrics

### API Connection Hooks

#### `api:beforeRequest`
**Trigger**: Before API request  
**Context**:
```javascript
{
  provider: string,
  payload: object,
  options: object
}
```
**Use Cases**: Modify requests, add headers

#### `api:afterRequest`
**Trigger**: After API response  
**Context**:
```javascript
{
  provider: string,
  request: object,
  response: object,
  duration: number,
  cost: number
}
```
**Use Cases**: Log responses, track costs

#### `api:onError`
**Trigger**: On API error  
**Context**:
```javascript
{
  provider: string,
  error: object,
  request: object,
  retryCount: number
}
```
**Use Cases**: Error handling, retry logic

#### `api:onThrottle`
**Trigger**: When rate limited  
**Context**:
```javascript
{
  provider: string,
  waitTime: number,
  queueLength: number
}
```
**Use Cases**: Queue management, fallback providers

#### `api:trackPerformance`
**Trigger**: Periodically for metrics  
**Context**:
```javascript
{
  provider: string,
  latency: number,
  throughput: number,
  errorRate: number
}
```
**Use Cases**: Performance monitoring, SLA tracking

### Department & Manager Hooks

#### `department:beforeCoordination`
**Trigger**: Before department coordination  
**Context**:
```javascript
{
  departments: array,
  task: object,
  protocol: object
}
```

#### `department:afterCoordination`
**Trigger**: After coordination complete  
**Context**:
```javascript
{
  protocol: object,
  success: boolean,
  results: object
}
```

#### `manager:beforeDecision`
**Trigger**: Before manager decision  
**Context**:
```javascript
{
  manager: string,
  context: object,
  decision: null,
  options: array
}
```

#### `manager:validateDecision`
**Trigger**: During decision validation  
**Context**:
```javascript
{
  decision: object,
  valid: boolean,
  errors: array
}
```

#### `manager:afterDecision`
**Trigger**: After decision made  
**Context**:
```javascript
{
  decision: object,
  approved: boolean,
  implementation: object
}
```

### Orchestrator Hooks

#### `orchestrator:beforeTaskProcessing`
**Trigger**: Before processing task  
**Context**:
```javascript
{
  task: object,
  orchestratorState: object
}
```

#### `orchestrator:afterTaskProcessing`
**Trigger**: After task complete  
**Context**:
```javascript
{
  task: object,
  result: object,
  success: boolean
}
```

#### `orchestrator:budgetCheck`
**Trigger**: Before expensive operations  
**Context**:
```javascript
{
  operation: string,
  estimatedCost: number,
  remainingBudget: number
}
```

#### `orchestrator:healthCheck`
**Trigger**: During health monitoring  
**Context**:
```javascript
{
  health: object,
  alerts: array
}
```

### Claude Max Hooks

#### `claudemax:beforeLockAcquisition`
**Trigger**: Before acquiring lock  
**Context**:
```javascript
{
  agentId: string,
  agentType: string,
  taskType: string,
  priority: number
}
```

#### `claudemax:suggestAlternative`
**Trigger**: When lock unavailable  
**Context**:
```javascript
{
  lockAvailable: boolean,
  alternativeModel: string,
  reason: string
}
```

#### `claudemax:lockGranted`
**Trigger**: After lock acquired  
**Context**:
```javascript
{
  agentId: string,
  lockId: string,
  expiresAt: number
}
```

#### `claudemax:lockReleased`
**Trigger**: After lock released  
**Context**:
```javascript
{
  agentId: string,
  duration: number,
  tokensUsed: number
}
```

## Usage Guide

### Registering a Hook Handler

```javascript
// Basic handler registration
orchestrator.hooks.registerHandler('model:evaluateCost', async (context) => {
  // Your custom logic here
  if (context.cost > threshold) {
    context.suggestAlternative = true;
  }
  return context;
});
```

### Handler with Priority

```javascript
// Higher priority executes first
orchestrator.hooks.registerHandler('team:validateComposition', 
  async (context) => {
    // Critical validation logic
    return context;
  },
  { priority: 100 }
);
```

### Multiple Handlers

```javascript
// Multiple handlers execute in priority order
orchestrator.hooks.registerHandler('api:afterRequest', logHandler);
orchestrator.hooks.registerHandler('api:afterRequest', metricsHandler);
orchestrator.hooks.registerHandler('api:afterRequest', costTracker);
```

### Preventing Default Behavior

```javascript
orchestrator.hooks.registerHandler('lifecycle:beforeTransition', async (context) => {
  if (shouldPrevent(context)) {
    context.preventDefault = true;
    context.reason = 'Conditions not met';
  }
  return context;
});
```

## Examples

### Example 1: Cost Optimization System

```javascript
// Track all costs
const costTracker = {
  total: 0,
  byModel: {}
};

// Evaluate costs before model selection
orchestrator.hooks.registerHandler('model:evaluateCost', async (context) => {
  const hourlyBudget = 5.00; // $5/hour
  const projectedCost = context.cost * 100; // 100 requests/hour
  
  if (projectedCost > hourlyBudget) {
    context.suggestAlternative = true;
    context.reason = `Projected cost $${projectedCost} exceeds budget`;
  }
  
  return context;
});

// Suggest cheaper alternatives
orchestrator.hooks.registerHandler('model:suggestAlternative', async (context) => {
  const alternatives = {
    'claude-max': 'deepseek',
    'gpt-4': 'qwen',
    'claude-2': 'gemini'
  };
  
  context.alternativeModel = alternatives[context.originalModel] || 'deepseek';
  context.costSavings = 0.014; // Average savings per request
  
  return context;
});

// Track actual costs
orchestrator.hooks.registerHandler('api:afterRequest', async (context) => {
  costTracker.total += context.cost;
  costTracker.byModel[context.provider] = 
    (costTracker.byModel[context.provider] || 0) + context.cost;
  
  // Alert if spending too fast
  if (costTracker.total > 100) {
    console.warn('ðŸŸ¡ High spending detected:', costTracker);
  }
  
  return context;
});
```

### Example 2: Team Size Optimization

```javascript
// Optimize team size based on task complexity
orchestrator.hooks.registerHandler('team:modifyComposition', async (context) => {
  const task = context.task;
  const team = context.composition;
  
  // Simple tasks need fewer agents
  if (task.complexity === 'simple' && team.members.length > 2) {
    context.modifications = {
      members: team.members.slice(0, 2)
    };
  }
  
  // Complex tasks need diverse skills
  if (task.complexity === 'complex') {
    const skills = new Set(team.members.flatMap(m => m.skills));
    if (skills.size < 5) {
      context.modifications = {
        additionalMembers: [{
          role: 'specialist',
          skills: ['architecture', 'security']
        }]
      };
    }
  }
  
  return context;
});
```

### Example 3: Knowledge Preservation

```javascript
// Preserve critical knowledge before deprecation
const criticalKnowledge = new Map();

orchestrator.hooks.registerHandler('deprecation:before', async (context) => {
  const agent = getAgent(context.agentId);
  
  // Save critical learnings
  criticalKnowledge.set(context.agentId, {
    patterns: agent.getLearnedPatterns(),
    optimizations: agent.getOptimizations(),
    errors: agent.getErrorPatterns()
  });
  
  return context;
});

// Transfer knowledge to new agents
orchestrator.hooks.registerHandler('lifecycle:afterTransition', async (context) => {
  if (context.currentState === 'active') {
    // Check for predecessor's knowledge
    const knowledge = findRelevantKnowledge(context.agentId);
    if (knowledge) {
      await transferKnowledge(context.agentId, knowledge);
    }
  }
  
  return context;
});
```

### Example 4: Performance Monitoring

```javascript
// Monitor system performance
const performanceMetrics = {
  responseTime: [],
  throughput: 0,
  errorRate: 0
};

orchestrator.hooks.registerHandler('orchestrator:afterTaskProcessing', async (context) => {
  // Track task processing time
  performanceMetrics.responseTime.push(context.duration);
  
  // Calculate moving average
  const recentTimes = performanceMetrics.responseTime.slice(-100);
  const avgTime = recentTimes.reduce((a, b) => a + b, 0) / recentTimes.length;
  
  // Alert if performance degrades
  if (avgTime > 5000) { // 5 seconds
    console.warn('ðŸŸ¡ Performance degradation detected:', avgTime);
    
    // Trigger optimization
    await triggerOptimization();
  }
  
  return context;
});
```

## Best Practices

### 1. **Keep Handlers Lightweight**
Hooks execute synchronously in the critical path. Keep logic minimal and fast.

```javascript
// ðŸ”´ Bad: Heavy computation in hook
orchestrator.hooks.registerHandler('api:beforeRequest', async (context) => {
  const analysis = await performComplexAnalysis(context); // Slow!
  return context;
});

// ðŸ Good: Queue heavy work
orchestrator.hooks.registerHandler('api:beforeRequest', async (context) => {
  queueAnalysis(context); // Fast, async
  return context;
});
```

### 2. **Always Return Context**
Handlers must return the context object to maintain the chain.

```javascript
// ðŸ”´ Bad: No return
orchestrator.hooks.registerHandler('team:validateComposition', async (context) => {
  validateTeam(context);
  // Missing return!
});

// ðŸ Good: Return context
orchestrator.hooks.registerHandler('team:validateComposition', async (context) => {
  validateTeam(context);
  return context; // Required!
});
```

### 3. **Handle Errors Gracefully**
Don't let handler errors break the system.

```javascript
orchestrator.hooks.registerHandler('model:evaluateCost', async (context) => {
  try {
    // Your logic
    return context;
  } catch (error) {
    console.error('Hook error:', error);
    return context; // Return unmodified context
  }
});
```

### 4. **Use Appropriate Priorities**
- **100**: Critical validations
- **75**: Important modifications
- **50**: Standard handlers
- **25**: Logging/metrics

### 5. **Avoid Side Effects**
Hooks should be predictable and not cause unexpected side effects.

```javascript
// ðŸ”´ Bad: Modifying global state
let globalCounter = 0;
orchestrator.hooks.registerHandler('api:afterRequest', async (context) => {
  globalCounter++; // Side effect!
  return context;
});

// ðŸ Good: Use context for state
orchestrator.hooks.registerHandler('api:afterRequest', async (context) => {
  context.requestCount = (context.requestCount || 0) + 1;
  return context;
});
```

## Performance Considerations

### Hook Execution Overhead
- Each hook adds ~1-5ms overhead
- Multiple handlers execute sequentially
- Use sparingly in hot paths

### Optimization Strategies

1. **Batch Operations**
```javascript
// Instead of per-request hooks, batch periodically
const batch = [];
orchestrator.hooks.registerHandler('api:afterRequest', async (context) => {
  batch.push(context);
  if (batch.length >= 100) {
    processBatch(batch);
    batch.length = 0;
  }
  return context;
});
```

2. **Cache Results**
```javascript
const cache = new Map();
orchestrator.hooks.registerHandler('model:evaluateCost', async (context) => {
  const key = `${context.model}-${context.requirements}`;
  if (cache.has(key)) {
    return cache.get(key);
  }
  
  // Expensive evaluation
  const result = await evaluate(context);
  cache.set(key, result);
  return result;
});
```

3. **Conditional Execution**
```javascript
orchestrator.hooks.registerHandler('team:validateComposition', async (context) => {
  // Skip validation for simple tasks
  if (context.task.complexity === 'simple') {
    return context;
  }
  
  // Complex validation only when needed
  return await complexValidation(context);
});
```

## Troubleshooting

### Common Issues

#### 1. Hook Not Firing
**Symptom**: Handler not executing  
**Causes**:
- Hook name typo
- Handler not registered
- Component not using hook system

**Solution**:
```javascript
// Verify registration
console.log(orchestrator.hooks.getRegisteredHooks());

// Add debug logging
orchestrator.hooks.registerHandler('yourHook', async (context) => {
  console.log('Hook fired!', context);
  return context;
});
```

#### 2. Context Modifications Lost
**Symptom**: Changes to context not persisting  
**Cause**: Not returning modified context

**Solution**:
```javascript
// Always return context
orchestrator.hooks.registerHandler('hook:name', async (context) => {
  context.modified = true;
  return context; // Don't forget!
});
```

#### 3. Performance Degradation
**Symptom**: System slowing down  
**Cause**: Heavy hook handlers

**Solution**:
```javascript
// Profile hook execution
const start = Date.now();
const result = await orchestrator.hooks.executeHooks('hook:name', context);
console.log(`Hook took ${Date.now() - start}ms`);
```

#### 4. Infinite Loops
**Symptom**: System hangs  
**Cause**: Hook triggering itself

**Solution**:
```javascript
// Add recursion guard
const executing = new Set();
orchestrator.hooks.registerHandler('hook:name', async (context) => {
  const key = `${context.id}`;
  if (executing.has(key)) return context;
  
  executing.add(key);
  try {
    // Your logic
    return context;
  } finally {
    executing.delete(key);
  }
});
```

### Debug Mode

Enable debug logging for hooks:

```javascript
// Enable debug mode
process.env.BUMBA_DEBUG_HOOKS = 'true';

// Or programmatically
orchestrator.hooks.debug = true;
```

### Hook Metrics

Monitor hook performance:

```javascript
const metrics = orchestrator.hooks.getMetrics();
console.log('Hook Metrics:', {
  totalExecutions: metrics.executions,
  averageTime: metrics.avgTime,
  slowestHook: metrics.slowest
});
```

## Summary

The BUMBA Universal Hook System provides unprecedented control over system behavior with minimal code changes. By leveraging the 45+ hook points strategically, you can:

- **Reduce costs** by 30-40% through intelligent model selection
- **Optimize performance** through adaptive team composition
- **Ensure quality** with validation hooks
- **Preserve knowledge** across agent lifecycles
- **Monitor everything** with comprehensive metrics

The hook system is the key to making BUMBA adaptable to any use case while maintaining its core functionality and performance.