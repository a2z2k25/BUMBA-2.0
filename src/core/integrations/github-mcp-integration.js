/**
 * BUMBA GitHub MCP Server Integration
 * Enables sophisticated Git operations through the GitHub MCP server
 * Provides PR management, code review, and branch protection
 */

const { EventEmitter } = require('events');
const { logger } = require('../logging/bumba-logger');
const { exec } = require('child_process');
const { promisify } = require('util');
const execAsync = promisify(exec);

/**
 * GitHub MCP Integration for Agent Collaboration
 */
class GitHubMCPIntegration extends EventEmitter {
  constructor(config = {}) {
    super();
    
    this.config = {
      owner: config.owner || process.env.GITHUB_OWNER,
      repo: config.repo || process.env.GITHUB_REPO,
      token: config.token || process.env.GITHUB_TOKEN,
      baseUrl: config.baseUrl || 'https://api.github.com',
      useMCP: config.useMCP !== false, // Use MCP server if available
      ...config
    };
    
    // PR templates for different agent types
    this.prTemplates = {
      feature: {
        title: '[FEATURE] {task}',
        labels: ['enhancement', 'agent-generated'],
        template: `## Summary
{summary}

## Changes Made
{changes}

## Agent Details
- **Agent ID**: {agentId}
- **Department**: {department}
- **Task**: {task}
- **Branch**: {branch}

## Testing
- [ ] Unit tests pass
- [ ] Integration tests pass
- [ ] Consciousness validation pass

## Checklist
- [ ] Code follows BUMBA standards
- [ ] Documentation updated
- [ ] No conflicts with main branch

---
*Generated by BUMBA Agent Team*`
      },
      
      bugfix: {
        title: '[FIX] {task}',
        labels: ['bug', 'agent-generated'],
        template: `## Bug Description
{description}

## Root Cause
{rootCause}

## Solution
{solution}

## Agent Details
- **Agent ID**: {agentId}
- **Department**: {department}

## Validation
- [ ] Bug reproduced before fix
- [ ] Fix verified
- [ ] Regression tests added

---
*Fixed by BUMBA Agent Team*`
      },
      
      refactor: {
        title: '[REFACTOR] {task}',
        labels: ['refactoring', 'agent-generated'],
        template: `## Refactoring Objective
{objective}

## Changes
{changes}

## Benefits
- {benefits}

## Agent Details
- **Agent ID**: {agentId}
- **Department**: {department}

## Quality Checks
- [ ] No functionality changes
- [ ] Performance maintained or improved
- [ ] Code complexity reduced

---
*Refactored by BUMBA Agent Team*`
      }
    };
    
    // Track active PRs
    this.activePRs = new Map();
    
    // Review requirements by department
    this.reviewRequirements = {
      'backend-engineer': ['security-review', 'performance-review'],
      'design-engineer': ['ux-review', 'accessibility-review'],
      'product-strategist': ['business-review', 'strategy-alignment']
    };
  }
  
  /**
   * Initialize GitHub MCP connection
   */
  async initialize() {
    try {
      if (this.config.useMCP) {
        // In production, connect to GitHub MCP server
        logger.info('🟢 Connecting to GitHub MCP server...');
        
        // Simulate MCP connection for now
        // In real implementation, this would use MCP client
        this.mcpConnected = false; // Would be true when MCP server is available
      }
      
      // Fallback to GitHub CLI
      if (!this.mcpConnected) {
        const ghVersion = await execAsync('gh --version').catch(() => null);
        
        if (ghVersion) {
          this.ghAvailable = true;
          logger.info('🏁 GitHub CLI available as fallback');
        }
      }
      
      this.emit('initialized', {
        mcp: this.mcpConnected,
        cli: this.ghAvailable
      });
      
    } catch (error) {
      logger.error('Failed to initialize GitHub integration:', error);
    }
  }
  
  /**
   * Create a Pull Request for agent work
   */
  async createPullRequest(agentInfo, reviewerAgent = null) {
    const { agentId, branch, task, department, commits } = agentInfo;
    
    try {
      // Determine PR type
      const prType = this.determinePRType(task);
      const template = this.prTemplates[prType];
      
      // Generate PR body from template
      const prBody = this.generatePRBody(template.template, {
        agentId,
        department,
        task,
        branch,
        summary: this.generateSummary(commits),
        changes: await this.getChangeSummary(branch)
      });
      
      // Create PR using GitHub CLI or API
      let pr;
      
      if (this.ghAvailable) {
        // Use GitHub CLI
        pr = await this.createPRWithCLI({
          title: template.title.replace('{task}', task),
          body: prBody,
          branch,
          labels: template.labels
        });
      } else if (this.mcpConnected) {
        // Use MCP server
        pr = await this.createPRWithMCP({
          title: template.title.replace('{task}', task),
          body: prBody,
          branch,
          labels: template.labels
        });
      } else {
        // Fallback to direct API
        pr = await this.createPRWithAPI({
          title: template.title.replace('{task}', task),
          body: prBody,
          branch,
          labels: template.labels
        });
      }
      
      // Track PR
      this.activePRs.set(agentId, {
        prNumber: pr.number,
        url: pr.url,
        status: 'open',
        createdAt: new Date(),
        reviewer: reviewerAgent
      });
      
      // Request reviews if specified
      if (reviewerAgent) {
        await this.requestReview(pr.number, reviewerAgent, department);
      }
      
      // Set up status checks
      await this.setupStatusChecks(pr.number, department);
      
      this.emit('pr-created', {
        agentId,
        pr,
        reviewer: reviewerAgent
      });
      
      return pr;
      
    } catch (error) {
      logger.error(`Failed to create PR for agent ${agentId}:`, error);
      throw error;
    }
  }
  
  /**
   * Create PR using GitHub CLI
   */
  async createPRWithCLI(options) {
    const { title, body, branch, labels } = options;
    
    try {
      // Create PR
      const createCmd = `gh pr create --title "${title}" --body "${body}" --base main --head ${branch}`;
      const { stdout } = await execAsync(createCmd);
      
      // Extract PR URL and number
      const prUrl = stdout.trim();
      const prNumber = prUrl.split('/').pop();
      
      // Add labels
      if (labels && labels.length > 0) {
        await execAsync(`gh pr edit ${prNumber} --add-label "${labels.join(',')}"`);
      }
      
      return {
        number: prNumber,
        url: prUrl,
        state: 'open'
      };
      
    } catch (error) {
      logger.error('Failed to create PR with CLI:', error);
      throw error;
    }
  }
  
  /**
   * Create PR using MCP server (when available)
   */
  async createPRWithMCP(options) {
    // This would use the MCP server protocol
    // Placeholder for MCP implementation
    logger.info('Creating PR via MCP server...');
    
    // Simulate MCP response
    return {
      number: `pr-${Date.now()}`,
      url: `https://github.com/${this.config.owner}/${this.config.repo}/pull/XXX`,
      state: 'open'
    };
  }
  
  /**
   * Create PR using GitHub API directly
   */
  async createPRWithAPI(options) {
    const { title, body, branch, labels } = options;
    
    const apiUrl = `${this.config.baseUrl}/repos/${this.config.owner}/${this.config.repo}/pulls`;
    
    const response = await fetch(apiUrl, {
      method: 'POST',
      headers: {
        'Authorization': `token ${this.config.token}`,
        'Content-Type': 'application/json'
      },
      body: JSON.stringify({
        title,
        body,
        head: branch,
        base: 'main'
      })
    });
    
    if (!response.ok) {
      throw new Error(`GitHub API error: ${response.statusText}`);
    }
    
    const pr = await response.json();
    
    // Add labels
    if (labels && labels.length > 0) {
      await this.addLabels(pr.number, labels);
    }
    
    return pr;
  }
  
  /**
   * Request review from manager or peer agents
   */
  async requestReview(prNumber, reviewerAgent, department) {
    try {
      // Get review requirements for department
      const requirements = this.reviewRequirements[department] || [];
      
      if (this.ghAvailable) {
        // Request review via CLI
        await execAsync(`gh pr review ${prNumber} --request`);
      }
      
      // Create review checklist
      const checklist = {
        prNumber,
        reviewer: reviewerAgent,
        requirements,
        checks: requirements.map(req => ({
          name: req,
          status: 'pending',
          requiredFor: 'merge'
        })),
        requestedAt: new Date()
      };
      
      this.emit('review-requested', checklist);
      
      return checklist;
      
    } catch (error) {
      logger.error(`Failed to request review for PR ${prNumber}:`, error);
    }
  }
  
  /**
   * Manager approves or requests changes on PR
   */
  async submitReview(prNumber, managerAgent, decision, comments = '') {
    try {
      const review = {
        prNumber,
        reviewer: managerAgent,
        decision, // 'APPROVE', 'REQUEST_CHANGES', 'COMMENT'
        comments,
        timestamp: new Date()
      };
      
      if (this.ghAvailable) {
        // Submit review via CLI
        const reviewCmd = decision === 'APPROVE' 
          ? `gh pr review ${prNumber} --approve --body "${comments}"`
          : decision === 'REQUEST_CHANGES'
          ? `gh pr review ${prNumber} --request-changes --body "${comments}"`
          : `gh pr review ${prNumber} --comment --body "${comments}"`;
          
        await execAsync(reviewCmd);
      }
      
      // Update PR tracking
      const prInfo = Array.from(this.activePRs.values())
        .find(pr => pr.prNumber === prNumber);
        
      if (prInfo) {
        prInfo.lastReview = review;
        prInfo.status = decision === 'APPROVE' ? 'approved' : 'changes_requested';
      }
      
      // Auto-merge if approved and all checks pass
      if (decision === 'APPROVE' && this.config.autoMerge) {
        await this.attemptAutoMerge(prNumber);
      }
      
      this.emit('review-submitted', review);
      
      return review;
      
    } catch (error) {
      logger.error(`Failed to submit review for PR ${prNumber}:`, error);
      throw error;
    }
  }
  
  /**
   * Attempt to auto-merge approved PR
   */
  async attemptAutoMerge(prNumber) {
    try {
      // Check if all status checks pass
      const checksPass = await this.checkStatus(prNumber);
      
      if (!checksPass) {
        logger.info(`⏸️ PR ${prNumber} waiting for status checks`);
        return false;
      }
      
      if (this.ghAvailable) {
        // Merge via CLI
        await execAsync(`gh pr merge ${prNumber} --auto --squash`);
        logger.info(`🏁 PR ${prNumber} set to auto-merge`);
      }
      
      this.emit('pr-merged', { prNumber, method: 'auto' });
      
      return true;
      
    } catch (error) {
      logger.error(`Failed to auto-merge PR ${prNumber}:`, error);
      return false;
    }
  }
  
  /**
   * Set up required status checks for PR
   */
  async setupStatusChecks(prNumber, department) {
    const checks = [
      'consciousness-validation',
      'unit-tests',
      'integration-tests',
      'code-quality',
      'security-scan'
    ];
    
    // Add department-specific checks
    if (department === 'backend-engineer') {
      checks.push('performance-tests', 'api-tests');
    } else if (department === 'design-engineer') {
      checks.push('visual-regression', 'accessibility-tests');
    }
    
    // In production, this would set up GitHub Actions or other CI/CD checks
    this.emit('status-checks-configured', {
      prNumber,
      checks
    });
    
    return checks;
  }
  
  /**
   * Check status of PR checks
   */
  async checkStatus(prNumber) {
    try {
      if (this.ghAvailable) {
        const { stdout } = await execAsync(`gh pr checks ${prNumber}`);
        
        // Parse check results
        const failedChecks = stdout.includes('🟢') || stdout.includes('fail');
        return !failedChecks;
      }
      
      // Default to true if we can't check
      return true;
      
    } catch (error) {
      logger.error(`Failed to check status for PR ${prNumber}:`, error);
      return false;
    }
  }
  
  /**
   * Handle merge conflicts in PR
   */
  async resolveConflicts(prNumber, strategy = 'rebase') {
    try {
      if (this.ghAvailable) {
        if (strategy === 'rebase') {
          // Rebase branch on main
          await execAsync(`gh pr checkout ${prNumber}`);
          await execAsync('git pull origin main --rebase');
          await execAsync('git push --force-with-lease');
        } else if (strategy === 'merge') {
          // Merge main into branch
          await execAsync(`gh pr checkout ${prNumber}`);
          await execAsync('git pull origin main');
          await execAsync('git push');
        }
      }
      
      this.emit('conflicts-resolved', {
        prNumber,
        strategy
      });
      
      return true;
      
    } catch (error) {
      logger.error(`Failed to resolve conflicts for PR ${prNumber}:`, error);
      return false;
    }
  }
  
  /**
   * Get change summary for branch
   */
  async getChangeSummary(branch) {
    try {
      const { stdout } = await execAsync(
        `git diff main...${branch} --stat`
      );
      
      return stdout;
      
    } catch (error) {
      return 'Unable to generate change summary';
    }
  }
  
  /**
   * Generate summary from commits
   */
  generateSummary(commits) {
    if (!commits || commits.length === 0) {
      return 'No commit summary available';
    }
    
    return commits
      .map(c => `- ${c.message}`)
      .join('\n');
  }
  
  /**
   * Generate PR body from template
   */
  generatePRBody(template, data) {
    let body = template;
    
    for (const [key, value] of Object.entries(data)) {
      body = body.replace(new RegExp(`{${key}}`, 'g'), value || '');
    }
    
    return body;
  }
  
  /**
   * Determine PR type from task description
   */
  determinePRType(task) {
    const taskLower = task.toLowerCase();
    
    if (taskLower.includes('fix') || taskLower.includes('bug')) {
      return 'bugfix';
    } else if (taskLower.includes('refactor')) {
      return 'refactor';
    } else {
      return 'feature';
    }
  }
  
  /**
   * Add labels to PR
   */
  async addLabels(prNumber, labels) {
    if (this.ghAvailable) {
      await execAsync(`gh pr edit ${prNumber} --add-label "${labels.join(',')}"`);
    }
  }
  
  /**
   * Get collaboration metrics
   */
  getMetrics() {
    const activePRsList = Array.from(this.activePRs.values());
    
    return {
      totalPRs: activePRsList.length,
      openPRs: activePRsList.filter(pr => pr.status === 'open').length,
      approvedPRs: activePRsList.filter(pr => pr.status === 'approved').length,
      mergedPRs: activePRsList.filter(pr => pr.status === 'merged').length,
      averageReviewTime: this.calculateAverageReviewTime(activePRsList)
    };
  }
  
  /**
   * Calculate average review time
   */
  calculateAverageReviewTime(prs) {
    const reviewedPRs = prs.filter(pr => pr.lastReview);
    
    if (reviewedPRs.length === 0) {return 0;}
    
    const totalTime = reviewedPRs.reduce((sum, pr) => {
      const reviewTime = pr.lastReview.timestamp - pr.createdAt;
      return sum + reviewTime;
    }, 0);
    
    return Math.round(totalTime / reviewedPRs.length / 1000 / 60); // In minutes
  }
}

// Export singleton
let instance = null;

module.exports = {
  GitHubMCPIntegration,
  getInstance: (config) => {
    if (!instance) {
      instance = new GitHubMCPIntegration(config);
    }
    return instance;
  }
};