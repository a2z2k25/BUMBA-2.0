/**
 * BUMBA Intelligent Output Generator
 * Generates intelligent, context-aware outputs based on specialist analysis
 */

const { logger } = require('../logging/bumba-logger');
const fs = require('fs').promises;
const path = require('path');

class IntelligentOutputGenerator {
  constructor() {
    this.outputTemplates = new Map();
    this.initializeTemplates();
  }

  initializeTemplates() {
    // Initialize base templates for different output types
    this.outputTemplates.set('prd', this.generatePRDTemplate);
    this.outputTemplates.set('api', this.generateAPITemplate);
    this.outputTemplates.set('design', this.generateDesignTemplate);
    this.outputTemplates.set('database', this.generateDatabaseTemplate);
  }

  /**
   * Generate intelligent output based on command and analysis
   */
  async generateOutput(command, args, analysis, context) {
    logger.info(`âœ¨ Generating intelligent output for: ${command}`);
    
    const outputType = this.determineOutputType(command);
    const content = await this.createIntelligentContent(
      command,
      args,
      analysis,
      outputType
    );
    
    // Determine file format
    const format = this.getOutputFormat(command);
    const fileName = this.generateFileName(command, args, format);
    
    // Save to file
    const filePath = await this.saveOutput(fileName, content);
    
    return {
      success: true,
      fileName,
      filePath,
      format,
      analysis: {
        specialists: analysis.totalSpecialists,
        priority: analysis.consensus.priority,
        complexity: analysis.consensus.complexity,
        timeline: analysis.consensus.timeline
      }
    };
  }

  /**
   * Create intelligent content based on analysis
   */
  async createIntelligentContent(command, args, analysis, outputType) {
    const feature = args.join(' ') || command;
    
    switch(outputType) {
      case 'document':
        return this.generateIntelligentDocument(feature, analysis);
      case 'code':
        return this.generateIntelligentCode(feature, analysis);
      case 'specification':
        return this.generateIntelligentSpecification(feature, analysis);
      case 'configuration':
        return this.generateIntelligentConfiguration(feature, analysis);
      default:
        return this.generateGenericOutput(feature, analysis);
    }
  }

  /**
   * Generate intelligent PRD document
   */
  generateIntelligentDocument(feature, analysis) {
    const insights = analysis.insights.slice(0, 5).map(i => `- ${i}`).join('\n');
    const requirements = analysis.requirements.slice(0, 8).map(r => `- ${r}`).join('\n');
    const recommendations = analysis.recommendations.slice(0, 5).map(r => `- ${r}`).join('\n');
    const concerns = analysis.concerns.slice(0, 5).map(c => `- ${c}`).join('\n');
    
    return `# Product Requirements Document
## Feature: ${feature}

### Executive Summary
This PRD outlines the requirements for implementing ${feature}, based on analysis from ${analysis.totalSpecialists} specialist agents.

**Priority:** ${analysis.consensus.priority}
**Complexity:** ${analysis.consensus.complexity}
**Estimated Timeline:** ${analysis.consensus.timeline}

### Specialist Analysis Insights
${insights}

### Core Requirements
${requirements || '- Functional requirements to be defined\n- Non-functional requirements to be specified'}

### Technical Recommendations
${recommendations || '- Architecture patterns to be determined\n- Technology stack to be selected'}

### Risk Assessment & Concerns
${concerns || '- No critical concerns identified\n- Standard risk mitigation strategies apply'}

### Implementation Approach
Based on the ${analysis.consensus.complexity} complexity assessment, we recommend:
- Phased rollout approach
- Iterative development with continuous testing
- Regular stakeholder reviews

### Success Criteria
- All requirements met and tested
- Performance metrics achieved
- User acceptance testing passed
- Security audit completed

### Next Steps
1. Review and approve requirements
2. Create technical design document
3. Set up development environment
4. Begin sprint planning

---
*Generated by BUMBA Intelligent Command System*
*Analysis conducted by ${analysis.totalSpecialists} specialist agents*
*Generated at: ${new Date().toISOString()}*
`;
  }

  /**
   * Generate intelligent code
   */
  generateIntelligentCode(feature, analysis) {
    const componentName = feature.split(/[-\s]+/)
      .map(word => word.charAt(0).toUpperCase() + word.slice(1))
      .join('');
    
    const hasAuth = analysis.requirements.some(r => 
      r.toLowerCase().includes('auth') || r.toLowerCase().includes('security')
    );
    
    const hasData = analysis.requirements.some(r => 
      r.toLowerCase().includes('data') || r.toLowerCase().includes('validation')
    );
    
    return `import React, { useState, useEffect } from 'react';
${hasAuth ? "import { useAuth } from '../hooks/useAuth';" : ''}
${hasData ? "import { validateInput } from '../utils/validation';" : ''}
import styles from './${componentName}.module.css';

/**
 * ${componentName} Component
 * 
 * Specialist Recommendations:
${analysis.recommendations.slice(0, 3).map(r => ` * - ${r}`).join('\n')}
 */
const ${componentName} = ({ 
  onSubmit,
  initialData = {},
  ...props 
}) => {
  const [formData, setFormData] = useState(initialData);
  const [errors, setErrors] = useState({});
  const [loading, setLoading] = useState(false);
  ${hasAuth ? 'const { user, isAuthenticated } = useAuth();' : ''}
  
  useEffect(() => {
    // Initialize component based on specialist insights
    ${analysis.insights[0] ? `// ${analysis.insights[0]}` : ''}
  }, []);
  
  const handleSubmit = async (e) => {
    e.preventDefault();
    setLoading(true);
    
    ${hasData ? `
    // Validate input based on requirements
    const validationErrors = validateInput(formData);
    if (Object.keys(validationErrors).length > 0) {
      setErrors(validationErrors);
      setLoading(false);
      return;
    }
    ` : ''}
    
    try {
      await onSubmit(formData);
    } catch (error) {
      console.error('Submission error:', error);
      setErrors({ submit: error.message });
    } finally {
      setLoading(false);
    }
  };
  
  return (
    <div className={styles.container} {...props}>
      <form onSubmit={handleSubmit} className={styles.form}>
        {/* Implementation based on specialist analysis */}
        {errors.submit && (
          <div className={styles.error}>{errors.submit}</div>
        )}
        
        <button 
          type="submit" 
          disabled={loading}
          className={styles.submitButton}
        >
          {loading ? 'Processing...' : 'Submit'}
        </button>
      </form>
    </div>
  );
};

export default ${componentName};`;
  }

  /**
   * Generate intelligent API specification
   */
  generateIntelligentSpecification(feature, analysis) {
    const hasAuth = analysis.concerns.some(c => 
      c.toLowerCase().includes('auth') || c.toLowerCase().includes('security')
    );
    
    return `# API Specification: ${feature}

## Overview
${analysis.insights[0] || `API specification for ${feature} functionality`}

## Base Configuration
- **Base URL:** \`https://api.example.com/v1\`
- **Protocol:** HTTPS only
- **Authentication:** ${hasAuth ? 'Bearer token (JWT)' : 'API Key'}
- **Rate Limiting:** 1000 req/hour, 100 req/minute burst

## Endpoints

### GET /api/${feature.toLowerCase().replace(/\s+/g, '-')}
Retrieves ${feature} data

**Headers:**
\`\`\`
Authorization: Bearer {token}
Content-Type: application/json
\`\`\`

**Query Parameters:**
- \`page\` (integer): Page number for pagination
- \`limit\` (integer): Items per page (max: 100)
- \`sort\` (string): Sort field
- \`order\` (string): Sort order (asc/desc)

**Response 200:**
\`\`\`json
{
  "success": true,
  "data": [{
    "id": "uuid",
    "attributes": {},
    "created_at": "2024-01-01T00:00:00Z",
    "updated_at": "2024-01-01T00:00:00Z"
  }],
  "meta": {
    "page": 1,
    "limit": 10,
    "total": 100
  }
}
\`\`\`

### POST /api/${feature.toLowerCase().replace(/\s+/g, '-')}
Creates new ${feature}

**Request Body:**
\`\`\`json
{
  "data": {
    "type": "${feature.toLowerCase()}",
    "attributes": {
      // Required fields based on analysis
${analysis.requirements.slice(0, 3).map(r => `      // - ${r}`).join('\n')}
    }
  }
}
\`\`\`

### PUT /api/${feature.toLowerCase().replace(/\s+/g, '-')}/:id
Updates existing ${feature}

### DELETE /api/${feature.toLowerCase().replace(/\s+/g, '-')}/:id
Deletes ${feature}

## Error Responses
- \`400\`: Bad Request - Invalid input data
- \`401\`: Unauthorized - Invalid or missing token
- \`403\`: Forbidden - Insufficient permissions
- \`404\`: Not Found - Resource doesn't exist
- \`422\`: Unprocessable Entity - Validation errors
- \`429\`: Too Many Requests - Rate limit exceeded
- \`500\`: Internal Server Error

## Security Considerations
${analysis.concerns.filter(c => c.toLowerCase().includes('security')).map(c => `- ${c}`).join('\n') || '- Standard security practices apply'}

---
*Generated based on analysis from ${analysis.totalSpecialists} specialists*
`;
  }

  /**
   * Generate intelligent configuration
   */
  generateIntelligentConfiguration(feature, analysis) {
    return `# Configuration: ${feature}

## Environment Variables
\`\`\`env
# Application
APP_NAME=${feature.replace(/\s+/g, '_').toUpperCase()}
APP_ENV=production
APP_DEBUG=false

# Database
DB_CONNECTION=postgresql
DB_HOST=localhost
DB_PORT=5432
DB_DATABASE=${feature.toLowerCase().replace(/\s+/g, '_')}_db
DB_USERNAME=admin
DB_PASSWORD=secure_password

# Cache
CACHE_DRIVER=redis
REDIS_HOST=localhost
REDIS_PORT=6379

# Security
JWT_SECRET=generate_secure_secret
JWT_TTL=3600
ENCRYPTION_KEY=generate_encryption_key

# Performance
MAX_CONNECTIONS=100
TIMEOUT_SECONDS=30
RATE_LIMIT=1000
\`\`\`

## Docker Configuration
\`\`\`yaml
version: '3.8'
services:
  app:
    build: .
    environment:
      - NODE_ENV=production
    ports:
      - "3000:3000"
    depends_on:
      - db
      - redis
  
  db:
    image: postgres:14
    environment:
      POSTGRES_DB: ${feature.toLowerCase().replace(/\s+/g, '_')}_db
      POSTGRES_USER: admin
      POSTGRES_PASSWORD: secure_password
    volumes:
      - postgres_data:/var/lib/postgresql/data
  
  redis:
    image: redis:alpine
    ports:
      - "6379:6379"

volumes:
  postgres_data:
\`\`\`

## Recommendations from Specialists
${analysis.recommendations.map(r => `- ${r}`).join('\n')}

---
*Configuration based on ${analysis.consensus.complexity} complexity assessment*
`;
  }

  /**
   * Generate generic output
   */
  generateGenericOutput(feature, analysis) {
    return `# ${feature}

## Analysis Summary
- **Priority:** ${analysis.consensus.priority}
- **Complexity:** ${analysis.consensus.complexity}
- **Timeline:** ${analysis.consensus.timeline}
- **Specialists Consulted:** ${analysis.totalSpecialists}

## Key Insights
${analysis.insights.map(i => `- ${i}`).join('\n')}

## Requirements
${analysis.requirements.map(r => `- ${r}`).join('\n')}

## Recommendations
${analysis.recommendations.map(r => `- ${r}`).join('\n')}

## Concerns
${analysis.concerns.map(c => `- ${c}`).join('\n')}

---
*Generated by BUMBA Intelligent Command System*
`;
  }

  /**
   * Determine output type based on command
   */
  determineOutputType(command) {
    const documentCommands = ['prd', 'requirements', 'roadmap', 'docs'];
    const codeCommands = ['component', 'implement', 'ui'];
    const specCommands = ['api', 'design', 'analyze'];
    const configCommands = ['config', 'deploy', 'infrastructure'];
    
    if (documentCommands.includes(command)) return 'document';
    if (codeCommands.includes(command)) return 'code';
    if (specCommands.includes(command)) return 'specification';
    if (configCommands.includes(command)) return 'configuration';
    
    return 'generic';
  }

  /**
   * Get output file format
   */
  getOutputFormat(command) {
    const formats = {
      'prd': 'md',
      'requirements': 'md',
      'api': 'md',
      'component': 'jsx',
      'database': 'sql',
      'config': 'env',
      'infrastructure': 'yaml'
    };
    
    return formats[command] || 'md';
  }

  /**
   * Generate file name
   */
  generateFileName(command, args, format) {
    const timestamp = Date.now();
    const feature = args.join('-') || command;
    const sanitized = feature.replace(/[^a-z0-9-]/gi, '-').toLowerCase();
    
    return `${command}-${sanitized}-${timestamp}.${format}`;
  }

  /**
   * Save output to file
   */
  async saveOutput(fileName, content) {
    const filePath = path.join(process.cwd(), fileName);
    await fs.writeFile(filePath, content, 'utf8');
    logger.info(`ðŸ’¾ Saved output to: ${fileName}`);
    return filePath;
  }
}

// Singleton instance
let instance = null;

module.exports = {
  IntelligentOutputGenerator,
  getInstance: () => {
    if (!instance) {
      instance = new IntelligentOutputGenerator();
    }
    return instance;
  }
};